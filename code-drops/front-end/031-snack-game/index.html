<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>贪吃蛇游戏</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>经典贪吃蛇</h1>
  <div id="game-container">
      <!-- 游戏开始前的难度选择界面 -->
      <div id="start-screen" class="overlay">
          <h2>选择难度</h2>
          <button id="easy-btn" class="difficulty-btn">简单</button>
          <button id="medium-btn" class="difficulty-btn">中等</button>
          <button id="hard-btn" class="difficulty-btn">困难</button>
      </div>
      
      <!-- 游戏主画布 -->
      <canvas id="game-canvas"></canvas>
      
      <!-- 游戏结束界面 -->
      <div id="game-over-overlay" class="overlay">
          <div id="game-over-text">游戏结束！</div>
          <div id="final-score"></div>
          <button id="restart-button">重新开始</button>
      </div>
  </div>
  <div id="score-display">得分: <span id="score">0</span></div>
  <script src="main.js"></script>
</body>
</html>



<!-- 游戏实现思路 -->

<!-- 

第一步：搭建“舞台” - 游戏世界与网格

我们首先需要一个地方来玩游戏，这就是我们的“舞台”。

1.  画布（Canvas）： 在网页上，最适合做这种动态绘图的就是 HTML5 的 `<canvas>` 标签。它就像一块真正的画布，你可以用 JavaScript 在上面画任何东西。

2.  网格系统（Grid System）： 这是贪吃蛇的精髓，也是你问到的“网格背景怎么做”的核心。
     思路： 虽然 Canvas 是基于像素的，但我们的游戏逻辑是基于“格子”的。我们不需要真的去画一个永久的网格背景。更重要的是，在脑中和代码中建立一个虚拟的网格。
     实现： 我们定义两个核心变量：
         `gridSize = 20`：表示每个格子是 20x20 像素。
         `tileCount = 20`：表示我们的游戏区域是 20x20 个格子。
     坐标转换： 从此以后，我们所有的逻辑，比如蛇的位置、食物的位置，都用格子的坐标来表示（例如 `{x: 5, y: 10}`），而不是像素坐标。当需要绘制时，我们再把它转换成像素坐标：`像素x = 格子x  gridSize`。这样一来，所有的计算都变得非常简单和清晰。

第二步：创造“主角” - 蛇的表示与移动


1.  蛇的数据结构： 蛇是由很多节身体组成的，所以用一个数组来表示它最合适。数组里的每一个元素都是一个记录了 `{x, y}` 坐标的对象。
     例如：`let snake = [ {x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10} ];`
     这个数组的第一个元素 `snake[0]` 永远代表蛇头。

2.  蛇的移动控制： 这是另一个核心问题，“移动怎么控制”。
     自动移动： 蛇是自己不停在动的。我们用两个变量 `dx` 和 `dy` 来表示它的“速度”或者说“方向”。
         向右移动：`dx = 1, dy = 0`
         向左移动：`dx = -1, dy = 0`
         向下移动：`dx = 0, dy = 1`
         向上移动：`dx = 0, dy = -1`
     移动的实现（这是最巧妙的部分）：
        1.  根据当前方向 `(dx, dy)`，计算出下一个新的蛇头位置。例如，`newHead = { x: snake[0].x + dx, y: snake[0].y + dy }`。
        2.  用 `snake.unshift(newHead)` 方法将这个新蛇头添加到数组的最前面。
        3.  用 `snake.pop()` 方法从数组的末尾移除最后一节身体（蛇尾）。
         这一“加头去尾”的操作，就完美地模拟出了蛇向前移动一格的效果，而蛇的总长度保持不变。

3.  玩家的控制： 玩家并不是直接控制蛇，而是改变蛇下一次要移动的方向。
     我们监听键盘的按键事件（`keydown`）。
     当玩家按下“上箭头”，我们并不会马上让蛇向上移动，而是把方向变量更新为 `dx = 0, dy = -1`。
     注意点： 要做一个判断，防止蛇头瞬间180度掉头。比如，当蛇正在向右移动时（`dx`是1），就不能响应向左的按键。

第三步：设置“目标” - 食物、得分与成长

1.  食物的生成：
     食物也用一个 `{x, y}` 坐标对象表示。
     要随机生成食物，我们就在 `0` 到 `tileCount - 1` 的范围内随机生成一个 x 和 y 坐标。
     注意点： 生成食物后，必须检查这个位置是否已经在蛇的身体上。如果是，就要重新生成，直到找到一个空白的格子为止。

2.  吃食物与响应： 这是你问到的“蛇吃到方块之后怎么响应点数的增加”。
     判断是否吃到： 在蛇每次移动之后，我们都检查蛇头 `snake[0]` 的坐标是否和食物 `food` 的坐标完全重合。
     如果重合，就触发一连串的响应：
        1.  分数增加： `score += 10`。然后更新页面上显示分数的地方。
        2.  蛇身增长： 这是第二个巧妙的地方。还记得蛇移动是“加头去尾”吗？当蛇吃到食物时，我们只执行“加头”(`snake.unshift`)操作，而不执行“去尾”(`snake.pop`)操作。这样，蛇的身体数组就自然而然地增加了一节，蛇就变长了！
        3.  生成新食物： 调用我们之前写的食物生成函数，在新的随机位置上创建下一个食物。

第四步：制定“规则” - 游戏结束与重来

1.  游戏结束的条件：
     撞墙： 检查蛇头 `snake[0]` 的坐标是否超出了我们的网格边界（比如 x < 0 或 x >= tileCount）。
     撞自己： 检查蛇头 `snake[0]` 的坐标是否和它自己身体的任何一节（除了头以外）的坐标重合。我们用一个循环，从蛇的第四节开始检查（因为头不可能撞到紧随其后的脖子），看坐标是否相等。

2.  游戏结束的处理：
     我们用一个布尔变量，比如 `gameOver = true` 来标记游戏结束状态。
     在游戏的主循环中，一旦检测到 `gameOver` 为 `true`，就停止所有游戏逻辑的更新，并显示“游戏结束”的界面和最终得分。

第五步：驱动“引擎” - 游戏主循环（Game Loop）

以上所有的逻辑，都需要一个“引擎”来驱动它们按顺序、有节奏地执行。

 实现： 我们创建一个 `mainLoop` 函数，把一帧内需要做的所有事情都放进去：
    1.  检查游戏是否结束。
    2.  清空整个画布（为重绘做准备）。
    3.  移动蛇（包括处理吃食物的逻辑）。
    4.  检查是否发生碰撞（撞墙或撞自己）。
    5.  把更新后的蛇和食物全部重新画出来。
 循环的实现： 我们使用 `setTimeout(mainLoop, 100)`。这行代码的意思是：“在100毫秒后执行一次 `mainLoop` 函数”。而 `mainLoop` 函数的末尾又会调用自己，这样就形成了一个持续不断的循环。这个`100`毫秒就是蛇的移动速度，也就是我们设置难度的地方。

 总结

所以，整个思路就是：

搭建舞台（网格化思维） -> 创造角色（数组表示蛇） -> 制定核心玩法（加头去尾的移动，不“去尾”的成长） -> 设定规则（碰撞检测） -> 用一个主循环引擎把所有事情串联起来，按固定节奏周而复始地执行。

-->